# Week 2 리뷰

## 4. 정렬과 탐색

알고리즘 문제의 가장 기본이라고 불리는 정렬과 탐색.
해당 챕터에선 3종류의 정렬 알고리즘과 그 원리.
그리고 이진 트리를 기반으로 한 탐색 알고리즘에 대해 알아본다.

## 4.1 정렬 알고리즘
기본적인 정렬 알고리즘은 크게 3가지로 나뉜다.
1. O(n^2) 
2. O(n log n )
3. 하이브리드

책에서는 해당 부분에 대해 아주 가볍게 언급하고 넘어간다.<br>
그러나 그 원리에 대해선 명확하게 기술하고 있다.


## 4.1.1 버블 정렬
O(n^2)의 가장 대표적인 정렬이다. <br>
이 알고리즘은 n개의 원소 마다 n번 순회하며, 현재 항과 다음 항만을 비교하여 해당 비교항이 역위인 경우 swap 함수를 실행한다.

> ### 역위(inversion)
> 역위란 해당 배열의 인덱스의 크기와 실제 원소항의 크기가 다를 경우를 의미한다.<br>
> 개별 원소 별로 체크 한다.
> ```
> [1,4,5,3,2,6] 인 경우, 
> 역위는 0부터 시작하는 순서 기준으로 [1,3], [1,4], [2,3], [2,4], [3,4] 총 5쌍이 존재한다.
> 결국 정렬 알고리즘 이란 역위를 제거하는 알고리즘인 셈이다. 
> ```

```js
// 무조건 처음부터 끝까지 돈다..
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - 1; j++) {
      if (arr[j] > arr[j+1]) {
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
      }
    }
  }

  return arr;
}
```
## 4.1.2 병합 정렬
O(n log n)의 대표적인 정렬이다.<br>
병합 정렬은 단계마다 배열의 크기를 절반으로 줄여나가 배열이 원소단위가 지점까지 쪼갠다.

> ### 분할 정복 알고리즘<br>
> 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.<br>
분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.

병합 정렬의 과정은 다음과 같다.
array[p...r]
0. 이라고 가정하자. 
1. **분할.** ppp와 rrr의 중간 qqq를 찾습니다. 이진 검색에서 중간점을 찾았던 것과 같은 방법으로 이 과정을 수행합니다: ppp와 rrr을 더해서 2로 나눈 후 내림을 하여 정수로 만듭니다.
2. **정복.** 분할 단계에서 만들어진 두 하위 문제 각각에 있는 하위 배열을 재귀적으로 정렬합니다. 즉 하위 배열 array[p..q]를 재귀적으로 정렬하고 또 하위 배열array[q+1..r]을 재귀적으로 정렬합니다.
3. **결합.** 정렬된 두 하위 배열을 하나의 정렬된 하위 배열인 array[p..r]로 결합합니다.
