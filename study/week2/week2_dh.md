# 2주차 스터디
### Chapter 2 정렬과 탐색(p.45\~p.60)
2주차 주제는 정렬과 탐색이다. 정렬은 알고리즘 스터디의 가장 기본이며 가장 중요한 내용이다.</br>
하지만 이 책에서 정렬과 탐색 파트에 15페이지의 짧은 분량과 이런게 있다는 식으로 보여주고 지나가는 방식이 마음에 들지 않는다.</br>
때문에 책에 나온 내용 뿐 아니라 나오지 않는 다른 정렬 방식도 같이 정리하기 위해 파트 순서는 내 마음대로 재구성해가며 정리할 예정이다.</br>
참고로 아래 적은 정렬 설명은 기본적으로 오름차순을 기준으로 설명을 하려고 한다.</br>
마지막으로 내가 자료구조로 정렬을 처음 배웠을 때 정렬 이름과 정렬 방식이 매칭이 되지 않았고, 
실제 테스트 코드도 콘솔로 구성되어 있었기 때문에 처음부터 잘 이해하기 어려웠던 것으로 기억한다.</br>
그럴땐 개념 공부와 코드를 짜본 후 옆의 링크와 같은 자료들을 함께 보는것도 좋은 방법인 것 같다. : 
[영상자료1](https://www.youtube.com/watch?v=vmT3XUBoxiQ&feature=emb_logo), 
[영상자료2](https://www.youtube.com/user/AlgoRythmics/videos)
</br></br>

##### 4.1 정렬 알고리즘 : O(n^2)</br>
##### 4.1.1 버블 정렬(Bubble sort)</br>
버블정렬은 서로 인접한 두 원소를 비교하고 정렬해 가는 O(n^2)의 복잡도를 가진 정렬 방식이다.</br>
배열의 가장 앞자리에서 라운드가 시작되며, 서로 인접한 두 배열의 인덱스 (a,b)가 a<b이지만 arr[a]>arr[b]의 관계이면 두 원소의 값을 교환(Swap)한다.</br>
한 라운드가 끝나면 이번 라운드의 가장 큰 값이 이번 라운드의 가장 끝 자리에 저장되고, 인덱스는 다시 0으로 돌아가며 다음 라운드의 끝 자리는 이번 라운드의 끝자리의 앞자리가 된다.</br>
장점은 단순하기 때문에 정렬을 처음 배우는 사람들에게 정렬이란 무엇인가 설명하고 보여주기 편하다는 점이다.</br>
때문에 거의 모든 자료구조/알고리즘의 책/강의 자료에서 정렬 파트의 가장 첫 부분을 버블 정렬이 많이 차지하고 있다.</br>
단점은 가장 큰 값을 교환(swap)해가며 뒤로 빼는 방식이기 때문에, 이미 제 자리로 들어와 있는 원소들도 교환 과정에서 다른 자리로 이동될 수 있다는 점이다.</br>
그리고 버블 정렬은 거의 모든 경우에서 최악의 성능을 보여주기 때문에(2중 포문에서 탐색 되는 모든 부분을 비교하고, 정렬을 위해서 SWAP을 이용함) 실제로 사용할 일이 거의 없다.</br>
```c++
// DHSEO : TODO - Bubble Code
```
</br></br>
##### 4.1.2 선택 정렬(Selection  sort)</br>
선택 정렬은 최소값을 찾아 맨 앞에 저장해가는 O(n^2)의 복잡도를 가진 정렬 방식이다.</br>
배열의 가장 앞자리에서 라운드가 시작되며, 이번 라운드의 가장 최소값의 원소를 찾은 후 인덱스가 시작된 자리(라운드 첫번째 자리)의 값과 교환(Swap)한다.</br>
한 라운드가 끝나면 이번 라운드의 가장 작은 값이 이번 라운드의 가장 앞 자리에 저장되고, 인덱스는 이번 라운드의 첫 자리 다음으로 초기화 된다.</br>
버블 정렬과 유사한 방식이지만, 옆 인덱스 값과 비교하여 현재 인덱스 값이 더 크면 교환(Swap)하는 버블 정렬과 달리, 
최소값을 먼저 찾은 후 한번의 교환(Swap)이 발생한다는 점이 차이점이다.</br>
때문에 정렬 성능에 대한 자료들을 찾아보면, 버블 정렬에 비해 약 2배 좋은 성능을 보여준다.</br>
또한 이미 정렬된 자료를 가지고 선택 정렬 로직을 돌리면 교환(Swap)이 발생하지 않는다는 특징이 있다.</br>
장점은 자료의 교환(swap) 버블 정렬과 마찬가지로 개념을 이해하기 쉬우며 자료의 비교/교환(swap) 횟수가 정해져 있다는 점이다.
그리고 선택 정렬은 정렬 과정에서 추가로 메모리가 필요하지 않는다.</br>
단점은 이 또한 버블정렬과 마찬가지로 뒤에 4.2 파트에서 설명할 정렬 방식에 비해 비효율적인 방식이라는 점이다.
```c++
// DHSEO : TODO - Selection Code
```
</br></br>
##### 4.1.3 삽입 정렬(Insertion  sort)</br>
삽입정렬은 선택된 인덱스 값 앞에 있는 정렬된 배열에 자기 자신의 위치를 찾아 삽입하는 O(n^2)의 복잡도를 가진 정렬 방식이다.</br>
첫 라운드는 배열의 두 번째 인덱스(1)부터 시작하며, 앞 인덱스 값이 자기 자신의 값보다 크면 그 갚을 뒤로 밀고 작으면 뒤에 자기 자신을 삽입한다.</br>
한 라운드가 끝나면 이번 라운드 다음 값이 Key값이 되어 다시 배열의 앞에 인덱스 값들과 비교한다.</br>
장점은 안정적인 정렬 방식이고, 개념 자체가 이해하기 쉽다는 점이다.</br>
단점은 정렬의 대상이 매우 크다면 많은 수의 비교와 이동이 필요하다는 점이다. 그리고 많은 이동이 요하는 방식이다.</br>
```c++
// DHSEO : TODO - Insertion Code
```
</br></br></br>
#### 4.2 정렬 알고리즘2 : O(nlogn)</br>
##### 4.2.1 병합 정렬(Marge  sort)</br>
```c++
// DHSEO : TODO - Marge Code
```
</br></br>
##### 4.2.2 힙 정렬(Heap  sort)</br>
```c++
// DHSEO : TODO - Heap Code
```
</br></br>
##### 4.2.3 퀵 정렬(Quick  sort)</br>
```c++
// DHSEO : TODO - Quick Code
```
</br></br></br>
#### 4.3 정렬을 이용한 문제풀이</br>
##### 4.3.1 스윕 라인 알고리즘(Sweep line algorithm)</br>

</br></br>
##### 4.3.2 이벤트 스케쥴링</br>

</br></br>
##### 4.3.3 작업과 데드라인</br>

</br></br></br>
#### 4.4 이진탐색</br>
##### 4.4.1 이진탐색 구현하기</br>

</br></br>
##### 4.4.2 최적해 구하기</br>

</br></br>
