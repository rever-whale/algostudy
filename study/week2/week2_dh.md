# 2주차 스터디
### Chapter 2 정렬과 탐색(p.45\~p.60)
2주차 주제는 정렬과 탐색이다. 정렬은 알고리즘 스터디의 가장 기본이며 가장 중요한 내용이다.</br>
하지만 이 책에서 정렬과 탐색 파트에 15페이지의 짧은 분량과 이런게 있다는 식으로 보여주고 지나가는 방식이 마음에 들지 않는다.</br>
때문에 책에 나온 내용 뿐 아니라 나오지 않는 다른 정렬 방식도 같이 정리하기 위해 파트 순서는 내 마음대로 재구성해가며 정리할 예정이다.</br>
참고로 아래 적은 정렬 설명은 기본적으로 오름차순을 기준으로 설명을 하려고 한다.</br>
마지막으로 내가 자료구조로 정렬을 처음 배웠을 때 정렬 이름과 정렬 방식이 매칭이 되지 않았고, 
실제 테스트 코드도 콘솔로 구성되어 있었기 때문에 처음부터 잘 이해하기 어려웠던 것으로 기억한다.</br>
그럴땐 개념 공부와 코드를 짜본 후 옆의 링크와 같은 자료들을 함께 보는것도 좋은 방법인 것 같다. : 
[영상자료1](https://www.youtube.com/watch?v=vmT3XUBoxiQ&feature=emb_logo), 
[영상자료2](https://www.youtube.com/user/AlgoRythmics/videos)
</br></br>

##### 4.1 정렬 알고리즘 : O(n^2)</br>
##### 4.1.1 버블 정렬(Bubble sort)</br>
버블정렬은 서로 인접한 두 원소를 비교하고 정렬해 가는 O(n^2)의 복잡도를 가진 정렬 방식이다.</br>
배열의 가장 앞자리에서 라운드가 시작되며, 서로 인접한 두 배열의 인덱스 (a,b)가 a<b이지만 arr[a]>arr[b]의 관계이면 두 원소의 값을 교환(Swap)한다.</br>
한 라운드가 끝나면 이번 라운드의 가장 큰 값이 이번 라운드의 가장 끝 자리에 저장되고, 인덱스는 다시 0으로 돌아가며 다음 라운드의 끝 자리는 이번 라운드의 끝자리의 앞자리가 된다.</br>
장점은 단순하기 때문에 정렬을 처음 배우는 사람들에게 정렬이란 무엇인가 설명하고 보여주기 편하다는 점이다.</br>
때문에 거의 모든 자료구조/알고리즘의 책/강의 자료에서 정렬 파트의 가장 첫 부분을 버블 정렬이 많이 차지하고 있다.</br>
단점은 가장 큰 값을 교환(swap)해가며 뒤로 빼는 방식이기 때문에, 이미 제 자리로 들어와 있는 원소들도 교환 과정에서 다른 자리로 이동될 수 있다는 점이다.</br>
그리고 버블 정렬은 거의 모든 경우에서 최악의 성능을 보여주기 때문에(2중 포문에서 탐색 되는 모든 부분을 비교하고, 정렬을 위해서 SWAP을 이용함) 실제로 사용할 일이 거의 없다.</br>
```c++
// DHSEO : TODO - Bubble Code
```
</br></br>
##### 4.1.2 선택 정렬(Selection  sort)</br>
선택 정렬은 최소값을 찾아 맨 앞에 저장해가는 O(n^2)의 복잡도를 가진 정렬 방식이다.</br>
배열의 가장 앞자리에서 라운드가 시작되며, 이번 라운드의 가장 최소값의 원소를 찾은 후 인덱스가 시작된 자리(라운드 첫번째 자리)의 값과 교환(Swap)한다.</br>
한 라운드가 끝나면 이번 라운드의 가장 작은 값이 이번 라운드의 가장 앞 자리에 저장되고, 인덱스는 이번 라운드의 첫 자리 다음으로 초기화 된다.</br>
버블 정렬과 유사한 방식이지만, 옆 인덱스 값과 비교하여 현재 인덱스 값이 더 크면 교환(Swap)하는 버블 정렬과 달리, 
최소값을 먼저 찾은 후 한번의 교환(Swap)이 발생한다는 점이 차이점이다.</br>
때문에 정렬 성능에 대한 자료들을 찾아보면, 버블 정렬에 비해 약 2배 좋은 성능을 보여준다.</br>
또한 이미 정렬된 자료를 가지고 선택 정렬 로직을 돌리면 교환(Swap)이 발생하지 않는다는 특징이 있다.</br>
장점은 자료의 교환(swap) 버블 정렬과 마찬가지로 개념을 이해하기 쉬우며 자료의 비교/교환(swap) 횟수가 정해져 있다는 점이다.
그리고 선택 정렬은 정렬 과정에서 추가로 메모리가 필요하지 않는다.</br>
단점은 이 또한 버블정렬과 마찬가지로 뒤에 4.2 파트에서 설명할 정렬 방식에 비해 비효율적인 방식이라는 점이다.
```c++
// DHSEO : TODO - Selection Code
```
</br></br>
##### 4.1.3 삽입 정렬(Insertion  sort)</br>
삽입정렬은 선택된 인덱스 값 앞에 있는 정렬된 배열에 자기 자신의 위치를 찾아 삽입하는 O(n^2)의 복잡도를 가진 정렬 방식이다.</br>
첫 라운드는 배열의 두 번째 인덱스(1)부터 시작하며, 앞 인덱스 값이 자기 자신의 값보다 크면 그 갚을 뒤로 밀고 작으면 뒤에 자기 자신을 삽입한다.</br>
한 라운드가 끝나면 이번 라운드 다음 값이 Key값이 되어 다시 배열의 앞에 인덱스 값들과 비교한다.</br>
장점은 안정적인 정렬 방식이고, 개념 자체가 이해하기 쉽다는 점이다.</br>
단점은 정렬의 대상이 매우 크다면 많은 수의 비교와 이동이 필요하다는 점이다. 그리고 많은 이동이 요하는 방식이다.</br>
```c++
// DHSEO : TODO - Insertion Code
```
</br></br></br>
#### 4.2 정렬 알고리즘2 : O(nlogn)</br>
##### 4.2.1 병합 정렬(Marge  sort)</br>
존 폰 노이만(John von Neumann)이 제안한 O(nlogn)의 복잡도를 가진 정렬로 흔히 말하는 분할정복(Divide and conquer)의 방식을 따른다.</br>
분할(Divide)는 더 이상 나눌 수 없을때까지(원소가 하나만 존재할 때까지) 최대한 균등하게 2분할 해 나가는 부분이다.</br>
정복(Conquer)은 분할의 역순으로 정렬하며 합쳐가는 과정이다. 정렬 방법은 현재 나누워져 있는 두 데이터의 가장 첫 데이터끼리 비교하여 더 작은 데이터를 합쳐질 데이터의 가장 앞에 두는 방식이다.</br>
장점은 안정적인 정렬 방식으로, 입력 데이터가 무엇이던간에 정렬되는 방식과 시간은 동일하다.</br>
또한 병합정렬을 Linked List로 구성하면, 데이터 이동 없이 포인터의 변경으로 구현 가능한 제자리 정렬(In-Place sorting) 방식으로 구현할 수 있다.</br>
단점은 병합 정렬을 Array로 구현하면, 데이터의 임시 저장 공간이 필요하고 제자리 정렬을 구현할 수 없다.</br>
보통 알고리즘 문제를 풀때는 시간 제한이 있으므로 링크드리스트의 포인터 이동까지 생각해가면서 구현할 시간이 없을수도 있다. 때문에 입력값이 매우 큰 경우 배열을 이용한 병합 정렬을 사용했을 경우 함수 안에서 임시배열을 선언하기 때문에 메모리 초과가 날 가능성이 높다.</br>
```c++
// DHSEO : TODO - Marge Code
```
</br></br>
##### 4.2.2 힙 정렬(Heap  sort)</br>
최대 힙 트리(내림차순, 부모 노드가 자식 노드보다 큼)나 최소 힙 트리(오름차순, 자식 노드가 부모 노드보다 큼)를 구성해 정렬하는 정렬 방식으로 O(nlogn)의 복잡도를 가진다.</br>
참고로 힙 정렬은 오름차순으로 설명하는게 훨씬 편하니까 오름차순으로 설명하려고 한다.</br>
힙(Heap)은 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조로, 최댓값과 최솟값을 쉽게 확인 할 수 있는 자료구조이다.</br>
여기서 완전 이진트리(Complete Binary Tree)는 데이터가 루트(Root) 노트에서 시작해 자식 노드가 왼쪽/오른쪽으로 연결되어있는 구조의 이진트리를 말한다. 즉, 중간에 노트가 비어있지 않고 가득 찬 구조를 의미한다.</br>
힙정렬도 일종의 분할 정복 방식으로 구성할 수 있다.</br>
정렬을 위해서는 힙 생성 알고리즘(Heapify Algorithem)을 이용하여 우선 n개의 노드에 대한 완전 이진트리를 구성해야 한다.</br>
우선 트리에 삽입할 데이터를 트리의 가장 마지막 자리에 임시로 저장하고 부모 노드들과 비교하며 자기 자기 자리를 찾아간다.</br>
트리 구성이 완성되면 정렬을 위하여 최대 힙을 삭제하는 과정이 필요하다. 이 또한 앞에 삽입 정렬과 유사한데, 최대 힙에서는 루트 노드가 가장 큰 값이므로 우선 루트 노드의 값을 삭제한다.</br>
그리고 트리의 가장 마지막 노드를 루트 노드로 옮기고 루트를 기준으로 힙을 재구성하는 방식으로 정렬이 동작한다.</br>
장점은 시간복잡도가 좋은 편이고, 가장 큰/작은 값 몇개만 필요한 경우 전체 정렬을 하기보다 힙 정렬을 이용하여 그 몇개만 찾아내는것이 더 유리하다.
```c++
// DHSEO : TODO - Heap Code
```
</br></br>
##### 4.2.3 퀵 정렬(Quick  sort)</br>
```c++
// DHSEO : TODO - Quick Code
```
</br></br></br>
#### 4.3 정렬을 이용한 문제풀이</br>
##### 4.3.1 스윕 라인 알고리즘(Sweep line algorithm)</br>

</br></br>
##### 4.3.2 이벤트 스케쥴링</br>

</br></br>
##### 4.3.3 작업과 데드라인</br>

</br></br></br>
#### 4.4 이진탐색</br>
##### 4.4.1 이진탐색 구현하기</br>

</br></br>
##### 4.4.2 최적해 구하기</br>

</br></br>
