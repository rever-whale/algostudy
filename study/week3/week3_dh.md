# 3주차 스터디
### Chapter 5 자료 구조(p.61\~p.72)
이번주 스터디 주제는 자료구조이다. C에서는 기본적으로 배열(Array)와 포인터(Pointer)를 이용한 자료구조를 직접 만들고 사용해야 하는 반면, C++에서는 표준 라이브러리에서 중요한 자료 구조를 미리 정의하여 손쉽게 사용할 수 있게 만들어 놓았다. 기존에 C를 하다가 C++로 넘어오면 가장 편하게 느끼는 점 중에 하나가 바로 이 부분이다. 아무래도 자료구조를 직접 구현하다보면 메모리 누수나 예외처리 등을 민감하게 생각해야 하는데, 이 부분에 대한 기본적인 처리가 되어있기 때문에 C++을 이용할때는 어떻게 잘 사용하느냐만 고민하면 되기 때문이다.</br>
#### 5.1 동적 배열
- 동적 배열(Dynamic array)는 프로그램이 실행되는 동안 크기가 변할 수 있는 배열을 의미한다.
##### 5.1.1 벡터(Vector)
벡터(Vector)는 크기가 변할 수 있는 배열을 나타내는 시퀀스 컨테이너이다. 배열(Array)과 마찬가지로 백터는 연속된 저장 위치를 사용하므로, Iterator 등을 이용하여 효율적으로 각 요소(Element)들에 접근 할 수 있다. 하지만 배열은 배열의 크기를 명시적으로 선언해야 하는 반면, 백터는 동적으로 할당 된 배열을 사용하여 요소를 저장한다.</br>
중요한 개념 중 하나는 백터는 배열과 같이 연속된 저장 위치를 사용해야 한다는 점이다. 때문에 벡터의 메모리가 재 할당될 때는 단순히 메모리만 추가하는것이 아니라 크기가 늘어난 백터를 새로 할당하고 기존 벡터 있는 데이터를 모두 옮겨(move)놓는 작업이 백그라운드에서 행해진다. 이는 비교적 비싼 작업이므로 요소가 추가될 때마다 백터가 재 할당되지는 않는다. 대신 벡터는 가능한 많은 데이터를 수용하기 위해 약간의 추가 스토리지를 미리 할당하며 생성 된다.</br>
다른 동적 시퀀스 컨테이너(Deque, list, forward_lists 등)에 비해 요소에 접근 하는데 매우 효울적이고 맨 끝에 데이터를 추가하는 방식이기 때문에 데이터 추가가 효율적이다. 하지만 끝 이외의 자리에 데이터를 삽입하거나 삭제할 때, 삽입/삭제 하는 포지션을 중심으로 데이터를 밀거나 땡겨야 하기 때문에 성능이 저하될 수 있다.</br>
보통 벡터와 맵을 실무에서 많이 사용한다. 특히 Vecotr에 일반 데이터 타입이 아닌 구조체 등의 새로운 타입을 저장하고 관리하는 용도로 많이 사용한다.</br>
더 자세한 내용은 [cplusplus의 std::vector](http://www.cplusplus.com/reference/vector/vector/)의 내용을 참조하면 될 것 같다.</br>
##### 5.1.2 반복자의 범위
반복자(Iterator)는 배열 또는 컨테이너와 같은 다양한 오브젝트를 가리키고, 연산자를 이용하여 해당 범위의 요소를 반복할 수 있는 객체이다.</br>
또한 반복자는 포인터이므로 배열 또는 컨테이너의 다음 요소로 이동할 때 증가 연산자(++)을 이용할 수 있고, 데이터에 접근시 \*를 이용하여 접근할 수 있다.</br>
더 자세한 내용은 [cplusplus의 Iterator](http://www.cplusplus.com/reference/iterator/)의 내용을 참조하면 될 것 같다.</br>
##### 5.1.3 다른 자료 구조
덱(Deque)는 양쪽 끝 원소를 효율적으로 처리할 수 있는 동적 배열이다.</br>
스택(Stack)는 FILO(First In Last Out)구조를 가진 자료구조이다.</br>
큐(Queue)는 FIFO(First In First Out)구조를 가진 자료구조이다.</br></br>
#### 5.2 집합 자료 구조
##### 5.2.1 셋(Set)과 멀티셋(MultiSet)
C++ 표준 라이브러리에는 집합 자료구조가 두 개 있다.
1. Set : 균형 잡힌 이진 탐색 트리를 기반으로 만들어져 있으며, 정렬을 하며 데이터를 삽입한다. 연산은 O(logn) 시간에 동작한다.
2. Unordered_set : 해시 테이블을 기반으로 만들어져 있으며, 정렬을 하지 않고 데이터를 삽입한다. 평균적으로 O(1), 최악의 경우 O(n)의 시간에 동작한다.


두 가지 자료구조의 사용 방법은 같으며, Set의 특징 중 하나는 모든 원소가 서로 다르다는 점이다. 즉, 이미 있는 원소의 경우 추가되지 않는다는 특징을 가지고 있다.</br>
Set은 Vector와 비슷한 방식으로 사용 가능하지만 []를 이용하여 인덱스 접근이 불가능하다.</br></br>
멀티셋(MultiSet)은 같은 값을 여러개 가질 수 있는 집합이다. Set과 비슷한 방식으로 multiset과 unordered_multiset 자료구조가 존재한다.</br>
더 자세한 내용은 [cplusplus의 std::set](http://www.cplusplus.com/reference/set/set/?kw=set)의 내용을 참조하면 될 것 같다.</br>
##### 5.2.2 맵
맵(Map)은 키(Key)와 값의 쌍을 저장하는 집합이다. 맵은 배열의 일반화 된 형태라고 할 수 있다. 배열은 인덱스 기준으로 0부터 n-1까지의 연속 된 정수가 키값으로 사용되는 반면, Map에는 키값에 대한 제한이 없다.
C++ 표준 라이브러리에는 맵 자료구조가 두 개 있다.
1. Map : 균형 잡힌 이진 탐색 트리를 기반으로 하며, 원소에 접근하는 데 O(logn) 시간이 걸린다.
2. unordered_map : 해시를 이용하여 원소에 접근하는 데 평균적으로 O(1) 시간이 걸린다.

특정 키의 값을 요청했는데 그 키가 없는 경우, 키가 자동으로 생성되며 값은 기본값(0)이 들어간다.
더 자세한 내용은 [cplusplus의 std::map](http://www.cplusplus.com/reference/map/map/?kw=map)의 내용을 참조하면 될 것 같다.</br>
##### 5.2.3 우선순위 큐
우선순위 큐(Priority queue)는 원소의 추가, 탐색, 삭제 연산이 있는 멀티셋이다.</br>
이 때 탐색 및 삭제의 대상이 되는 원소는 최소 혹은 최대 원소이며, 둘 중 어느쪽이 다생이 되는지는 큐의 속성에 달려있다. Default는 내림차순/최대원소 기준으로 설정되어 있다.</br>
보통 우선순위 큐는 특별한 형태의 이진 트리인 힙(Heap)을 기반으로 만들어진다.</br>
그리고 2주차 주제인 정렬에 힙정렬에 사용되므로 기본 개념에 대한 이해가 필요할 것 같다.</br>
더 자세한 내용은 [cplusplus의 std::priority_queue](http://www.cplusplus.com/reference/queue/priority_queue/)의 내용을 참조하면 될 것 같다.</br>
##### 5.2.4 정책 기반 집합
g++ 컴파일러에는 c++ 표준 라이브러리에 없는 자료구조인 정책 기반(policy-based) 자료구조가 있다. 하지만 표준 라이브러리가 아니므로 그냥 이런 개념이 있다 정도만 이해하고 가면 될 것 같다.
