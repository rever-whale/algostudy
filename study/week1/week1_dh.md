# 1주차 
### Chapter 1\~3 (p.1\~p.44)
"알고리즘 트레이닝 프로그래밍 대회 입문 가이드"(https://book.naver.com/bookdb/book_detail.nhn?bid=14829160)를 스터디 북으로 정하고 진도에 맞춰 공부 후 공유를 하는 방식으로 스터디를 진행하기로 했다.
이 책은 알고리즘 대회를 준비하는 책이다. 때문에 종만북과 같이 알고리즘 기법에 대한 설명이라기 보다, 알고리즘 기법은 따로 공부를 해야하고 어떻게 사고하는가에 대한 공유를 하는 느낌이었다.
그리고 이 책은 C++ 기반으로 되어 있었기 때문에 나에게는 비교적 거부감이 많이 없었다.
첫주차에는 책을 읽고 정리하는 과정이기 때문에 책 내용 자체를 정리하기 보다는, 좀 더 알았으면 하는 내용을 적는 것을 하려고 한다.

1. 들어가며
    - 프로그래밍 대회의 대한 간단한 소개를 해 놓은 챕터이기 때문에 사실상 정리 할 내용이 없다.<br/><br/>
2. 프로그래밍 기법
    1. 언어적 특성<br/>
    c++ 관련 입출력 방식에 대한 설명이 나온 챕터이다. C++로 알고리즘 문제를 풀때 가장 기초적인 설정에 대한 내용이었다.<br/>
    알고리즘 문제는 보통 입력 값을 받은 후 생각한 대로 문제를 푼 후 출력값을 제출하여 채점하는 방식으로 이뤄진다.<br/>
    때문에 C++을 사용할 때 입/출력에 대한 패널티를 알지 못하면 출력을 하지 못해 0점 처리 되는 문제도 종종 발생한다.<br/><br/>
    특히 C++의 경우 std::cout, std::cin(나는 namespace에 std를 선언하는 것을 좋아하지 않는다.)의 경우 ios::sync_with_stdio(false), cin.tie(NULL)에 대한 설명이 간단하게 적혀있는데 생각보다 중요한 내용이라고 생각한다.<br/><br/>
    - ios::sync_with_stdio(false)<br/>
    c++ 표준인 iostream과 c 표준인 stdio의 동기화를 끊어주는 역할을 한다.<br/>
    기본적으로 표준 입출력 방식은 버퍼를 동기화해 사용한다. 따라서 c++ code에서 cin&cout과 printf&scanf를 혼용해서 쓰더라도 순서에 맞게 Thread safe하게 동작하는 것이다.<br/>
    하지만 동기화를 끊는다면 c++의 iostream만의 독립적인 버퍼를 생성하여 사용하고 버퍼 수가 줄기 때문에 실행 속도 자체는 향상한다. 하지만 해당 옵션을 false로 셋업하게 된다면, Thread safe하지 않게 된다.<br/>
    이 옵션은 Thread safe하지 않는 이유 때문에 실무에서는 거의 사용할 일이 없다고 생각한다. 하지만 알고리즘 대회는 보통 Single thread 환경에서 개발이 진행되기 때문에 사용하는 옵션인 것 같다.<br/><br/>
    - cin.tie(NULL)
    cin을 cout으로부터 untie 하는 옵션이다.<br/>
    stream을 tie하면 다른 stream에서 입출력 요청이 오기 전에 stream을 flash 시킨다.<br/>
    이는 User에게 입출력 메시지를 보여주고(cout) 입력을 기다리는(cin)에서 cin과 cout이 tie 된 상태라면, Program이 user에게 입력을 요구하기 전에 output buffer를 flush하게 된다.<br/>
    untie 된 상태에서는 output이 flush 되지 않은 상태로 user에게 입력을 요구하게 되며 따라서 입력을 요구하는 출력문이 출력되지 않는다.<br/>
    기본적으로 buffer가 가득차거나 수동적으로 flush를 시켜주지 않으면 출력되지 않는다.<br/>
    그러므로 cin과 cout을 untie하면, cin으로 입력을 받기 전에 cout 출력을 하고싶으면 명시적으로 cout buffer를 flush 해주어야 한다.<br/><br/>
    언어적 특성에는 수 처리에 대한 이야기도 나온다. 이 부분에서는 변수의 오버플로우에 대한 이야기가 나오는데, 실제로 업무를 할때 long long 대신 int형으로 자료를 받아 쓰레기 값으로 처리되는 경우를 종종 보게 된다. 모든 변수를 처리할때 입력/출력/계산 과정에서 오버플로우가 나지 않는 넉넉한(?) 자료형으로 사용해야 한다고 생각한다.<br/>
    그리고 실수부 부동 소수점에는 계산의 오차가 있기 때문에 == 연산자를 사용하는데 주의 해야 하는 말도 와닿는다.<br/><br/>
    마지막으로 typedef로 자료형을 짧게 만드는 부분에 대한 이야기가 나오는데, 나는 이 부분에 대해서는 자료형을 짧게 만들어야 한다는 의견에는 반대한다. 물론 긴 자료형을 쓰는 일은 귀찮은 일이지만 긴 자료형을 짧게 사용하다가 나오는 실수가 더 큰 문제가 될 수 있다고 생각하기 때문이다.<br/>
    비슷한 이유로 매크로의 사용도 선호하지 않는다.<br/>
    매크로가 때에 따라서는 편하게 동작하기는 하지만, 전처리 과정에서 define 된 코드를 복사해놓기 때문에 실행파일 크기 자체가 늘어난다.<br/>
    또한 스택 프레임을 사용할 수 없기 때문에 재귀 구조를 가져갈 수 없다는 단점도 있다.<br/><br/>
    2. 재귀적 알고리즘
    재귀 함수는 DFS등의 알고리즘 기법을 사용 할 때 자주 사용하게 되는 기법이다.<br/>
    재귀함수 자체는 매우 편리하 방법이긴 하지만 사용하기 까다로운 기법이다.<br/>
    재귀함수 탈출에 대한 룰이 엄격하게 정해지지 않으면 무한의 공간으로 빠질 수 있고, 또한 Stack overflow 에러를 발생할 수 있기 때문이다.<br/>
    그렇기 떄문에 재귀 함수를 만들떄는 항상 탈출 조건부터 먼저 정의하고 개발을 해야 한다.<br/>
    그리고 재귀함수를 사용하면 Thread 못지 않게 디버깅을 하기 매우 어렵다는 단점도 있다.<br/><br/>
    3. 비트 연산
    비트 연산은 개인적으로 시프트 연산과 마스크에서 자주 사용한다.<br/>
    Bit 연산의 가장 큰 장점은 적은 양의 메모리 사용으로 많은 정보를 담을 수 있고, 또 속도 또한 빠르다는 점이다.<br/>
    때문에 많은 양의 데이터를 사용해야 하는 환경에서 메모리를 아껴야 할 때, 그리고 임베디드 환경에서 많이 쓴다.<br/>
    다만 단점은 한번에 알아보기 힘들고 비트 연산 코드를 보면 한번 생각을 해야 이해를 할 수 있다는 점이다.<br/><br/>
3. 효율성
    1. 시간 복잡도
    시간 복잡도는 전공 과정에서 매우 짧게 배우지만 알고리즘을 풀 때는 강력한 힌트 중 하나다.<br/>
    보통 알고리즘 문제는 문제를 보고 구현을 하는 방식도 있지만, BFS, DFS, DP의 기법을 써서 풀어야 하는 문제도 많이 있다.<br/>
    특히 문제를 읽다 보면 "어? 이거 BFS, DFS 문제다" 라고 생각이 들지만 실제로는 BFS, DFS를 사용해서 풀면 Time over가 나는 경우가 많이 있었다.<br/>
    이를 방지하기 위해서는 입력값을 기준으로 어느정도의 복잡도가 나와야 이 문제가 풀리겠구나 역으로 힌트를 얻어야 한다.<br/>
    이 챕터 내용중 가장 마음에 들었던 나용은 아래와 같이 1초를 기준으로 입력의 크기와 추정 시간복잡도를 정리해주었다는 점이다.
    - n <= 10           O(n!)
    - n <= 20           O(2^n)
    - n <= 500          O(n^3)
    - n <= 5000         O(n^2)
    - n <= 10^6         O(nlongn) or O(n)
    - n이 매우 클떄     O(1) or O(logn)
    물론 이 복잡도가 무조건 이 시간을 보장하는것은 아니지만, 최소한 알고리즘 문제를 읽고 해법 구상을 할 때 충분히 도움을 받을 수 있는 점이기 때문에 알고리즘 문제 풀이에 꼭 필요한 개념이라고 생각한다.<br/><br/>
    2. 예제문제
    - 최대 부분 배열 합
    이 문제는 연속된 배열의 방을 더한 수가 가장 큰 경우를 찾는 문제에 대한 설명이다.
    보통 깊은 생각을 하지 않고 문제를 읽으면 책에서 소개한대로 O(n^3)이나 O(n^2)의 경우로 문제를 생각하기 쉽다.
    하지만 이런 경우 보통 위의 복잡도로 문제를 풀게되면 Time over되는 경우가 많이 있다.
    때문에 O(n^3)이나 O(n^2)의 복잡도로 문제를 고민하고 코드를 작성 할 시간을 아껴서 문제를 좀 더 생각해보고 파해법을 찾느냐를 보는 문제인 것 같다.
    이런 문제의 핵심은 문제에서 "연속된"이라는 힌트를 주었기 떄문에 한번 더 생각해볼 수 있는 기회가 있다고 생각한다.
    - 두 퀸 문제
    백트래킹에 대한 설명에 나온 문제와 같은 문제다. 그런데 점화식을 구해 O(1)로 문제를 푸는 방식을 왜 소개했는지 잘 모르겠다.(이해가 안감)

