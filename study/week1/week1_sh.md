# Week 1 리뷰

## 1.개요

이 책은 알고리즘 대회를 준비하기 위한 책이다.<br>
`알고리즘`을 준비한다기보단, `대회`를 준비한다 쪽에 가까운 느낌이다.

처음 이 책을 선정했던 것은, 제목에서 오는 가벼움과 함께 알고리즘을 해결하기 위해서였지 대회에 출전하기 위함은 아니었다. 그러나 1,2,3장에 펼쳐진 내용은 내 생각을 뒤엎기에 족했다. 

---

일반적으로 프론트엔드 계열에서 알고리즘을 준비하는 경우, 준비해할 요소는 많지 않다. 보다 정확히는 별로 없다. 
Javascript가 고수준의 api가 구현되있는 언어인만큼, 자료구조 등을 직접 구현해야할 필요성도 별로 없을 뿐더러, 대부분의 문제가 효율성을 크게 중요시 하지 않기 때문이다. 
> 이 점은 프론트엔드 프로그래밍이 `효율적으로 압축`시키는 것 보다는 `효율적으로 펼쳐`내는데 중점을 두기 때문이라고 생각한다. 실제로 문제도 그런 류의 문제가 많다.

이 책에서 나오는 주 언어는 c++이다.<br>
2장 부터 나오는 비트 연산자들의 향연은 알고리즘에 대한 접근에 대해 경계심을 불러 일으키기 족하다. 

32개 미만의 정수의 부분집합을 구하는데 있어, 위 책은 다음과 같은 방식을 소개한다. 

```c++
int x = 0; // 32bit number
x |= (1<<1);
x |= (1<<3);
x |= (1<<4);
x |= (1<<8);

// 00000000000000000000000100011010
```

알고리즘 세계에선 어떨지 모르겠지만, FE의 세계에선 이런 코드를 접할 일이 없다. (일단 이해하기도 힘들고)

어쨌든 이제 다사다난할 것이 뻔한 자바스크립트 유저의 c++ 알고리즘 여행은 이렇게 시작한다.

##### (1장은 간단한 소개 이므로 패스)

<br>
<br>
<br>

## 2. 프로그래밍 기법

위 챕터에서 다루는 프로그래밍 기법은 c++의 언어적 특성 이외에도 재귀적 알고리즘, 비트 연산에 대한 간단한 소개로 이루어져있다.

### 2.1 C++의 언어적 특성
입출력, 수, 자료형, 매크로, 타입정의
<br>


### 2.2 재귀적 알고리즘
재귀적 알고리즘은 고등 수학에서 다루는 점화식에 가깝다. <br>
이전 항과 현재 항 혹은 현재 항과 다음 항의 관계와 초기 정의값 (탈출 조건)을 정의한다.

프로그래밍적으로는 동적 계획법이 훨씬 훌륭하게 보일 수 있으나, 수학적인 측면에선 재귀적 알고리즘은 아름다운 알고리즘이 분명하다.
<br>
<br>
### 2.2.1 부분집합 생성하기
부분집합을 생성하기 위해 가장 손쉽게 해볼 수 있는 일은 공집합에서부터 전체집합까지 하나 하나 넣어보는 것이다. 

```js
// javascript
const n = 3;
const subsets = [];
const subset = [];
function search(k = 1) {
  if (k === n+1) {
    console.log(subset);
  } else {
    subset.push(k);
    search(k+1);
    subset.pop(k);
    search(k+1);
  }
}

search();
```

다음의 재귀코드는 원소의 개수 n개를 순회하며, 1부터 하나 하나 넣은 후 탐색을 종료한다. 여기서 모든 search는 n+1회의 순회를 거치게 된다. 

> 1이 있는지 없는 지, <br>
2가 있는지 없는 지, <br>
n이 있는지 없는 지, <br>
그리고 모두 순회했는 지.

결국 2^(n+1)회 만큼의 순회를 필요로 한다.
추후 다룰 효율성 챕터에서 언급하겠지만 해당 알고리즘의 시간 복잡도는 O(2^n)이다.

https://codepen.io/rever-whale/pen/xxbXoMx
<br>
<br>
### 2.2.2 순열 생성하기
순열을 생성하기 위해 일반적으로 사용할 수 있는 방법은 최초 값을 하나 정해서 해당 값으로 부터 다른 값들을 분기해나가며 확장하는 방법이다. <br>
이를 간단히 정의하면 다음과 같다.

```
# 조건
1) 순열의 길이가 전체 원소의 개수가 될 것
2) 이전에 포함하지 않은 남은 값을 작은 순서대로 포함할 것
2-1) 포함하지 않은 경우, 다음 순서로 미룬다.
```

```js
// javascript

var len = 3;
var permutation = [];
var chosen = new Array(len).fill(false);

function search() {
  if (permutation.length === len) {
    console.log(permutation);
  } else {
    for (let i = 0; i < len; i++) {
      if (!chosen[i]) {
        chosen[i] = true;
        permutation.push(i);
        search();
        chosen[i] = false;
        permutation.pop();
      }
    }
  }
}

```
<br>
<br>

### 2.2.3 퇴각 검색
퇴각 검색이란, 비어있는 해로 탐색을 시작하고, 단계마다 해를 확장해 나가는 방식의 알고리즘이다. (간단히 말하면 현재 항으로 부터 파생 가능한 모든 항을 탐색할 수 없을 때까지 탐색한다.)

책에서는 해당 알고리즘의 예제로 체스판을 들고 있다.<br> 

두 개의 퀸이 4*4 체스판에서 서로 공격할 수 없는 배치를 구하기 위해선, 1개의 퀸을 배치하고, 모든 칸에 대해서 나머지 퀸의 위치를 탐색, 다시 다음 칸으로 재배치 후 같은 과정을 반복한다.

```js
// 망할 백트래킹...

var col = new Array(16).fill(0);
var diag1 = new Array(16).fill(0);
var diag2 = new Array(16).fill(0);
var count = 0;
var n = 4;

function search(y = 0) {
  if (y === n) {
    count++;
    return;
  }

  for (var x = 0; x < n; x++) {
    if (!(col[x] || diag1[x+y] || diag2[x-y+n-1])) {
      col[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
      search(y+1);
      col[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
  }
}

search();
console.log(count);
```
