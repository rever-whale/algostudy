# Week 1 리뷰

## 1.개요

이 책은 알고리즘 대회를 준비하기 위한 책이다.<br>
`알고리즘`을 준비한다기보단, `대회`를 준비한다 쪽에 가까운 느낌이다.

처음 이 책을 선정했던 것은, 제목에서 오는 가벼움과 함께 알고리즘을 해결하기 위해서였지 대회에 출전하기 위함은 아니었다. 그러나 1,2,3장에 펼쳐진 내용은 내 생각을 뒤엎기에 족했다. 

---

일반적으로 프론트엔드 계열에서 알고리즘을 준비하는 경우, 준비해할 요소는 많지 않다. 보다 정확히는 별로 없다. 
Javascript가 고수준의 api가 구현되있는 언어인만큼, 자료구조 등을 직접 구현해야할 필요성도 별로 없을 뿐더러, 대부분의 문제가 효율성을 크게 중요시 하지 않기 때문이다. 
> 이 점은 프론트엔드 프로그래밍이 `효율적으로 압축`시키는 것 보다는 `효율적으로 펼쳐`내는데 중점을 두기 때문이라고 생각한다. 실제로 문제도 그런 류의 문제가 많다.

이 책에서 나오는 주 언어는 c++이다.<br>
2장 부터 나오는 비트 연산자들의 향연은 알고리즘에 대한 접근에 대해 경계심을 불러 일으키기 족하다. 

32개 미만의 정수의 부분집합을 구하는데 있어, 위 책은 다음과 같은 방식을 소개한다. 

```c++
int x = 0; // 32bit number
x |= (1<<1);
x |= (1<<3);
x |= (1<<4);
x |= (1<<8);

// 00000000000000000000000100011010
```

알고리즘 세계에선 어떨지 모르겠지만, FE의 세계에선 이런 코드를 접할 일이 없다. (일단 이해하기도 힘들고)

어쨌든 이제 다사다난할 것이 뻔한 자바스크립트 유저의 c++ 알고리즘 여행은 이렇게 시작한다.

##### (1장은 간단한 소개 이므로 패스)

<br>
<br>
<br>

## 2. 프로그래밍 기법

위 챕터에서 다루는 프로그래밍 기법은 c++의 언어적 특성 이외에도 재귀적 알고리즘, 비트 연산에 대한 간단한 소개로 이루어져있다.

### 2.1 C++의 언어적 특성
입출력, 수, 자료형, 매크로, 타입정의
<br>


### 2.2 재귀적 알고리즘
재귀적 알고리즘은 고등 수학에서 다루는 점화식에 가깝다. <br>
이전 항과 현재 항 혹은 현재 항과 다음 항의 관계와 초기 정의값 (탈출 조건)을 정의한다.

프로그래밍적으로는 동적 계획법이 훨씬 훌륭하게 보일 수 있으나, 수학적인 측면에선 재귀적 알고리즘은 아름다운 알고리즘이 분명하다.
<br>
<br>

### 2.2.1 부분집합 생성하기
부분집합을 생성하기 위해 가장 손쉽게 해볼 수 있는 일은 공집합에서부터 전체집합까지 하나 하나 넣어보는 것이다. 

```js
// javascript
const n = 3;
const subsets = [];
const subset = [];
function search(k = 1) {
  if (k === n+1) {
    console.log(subset);
  } else {
    subset.push(k);
    search(k+1);
    subset.pop(k);
    search(k+1);
  }
}

search();
```

다음의 재귀코드는 원소의 개수 n개를 순회하며, 1부터 하나 하나 넣은 후 탐색을 종료한다. 여기서 모든 search는 n+1회의 순회를 거치게 된다. 

> 1이 있는지 없는 지, <br>
2가 있는지 없는 지, <br>
n이 있는지 없는 지, <br>
그리고 모두 순회했는 지.

결국 2^(n+1)회 만큼의 순회를 필요로 한다.
추후 다룰 효율성 챕터에서 언급하겠지만 해당 알고리즘의 시간 복잡도는 O(2^n)이다.

https://codepen.io/rever-whale/pen/xxbXoMx
<br>
<br>

### 2.2.2 순열 생성하기
순열을 생성하기 위해 일반적으로 사용할 수 있는 방법은 최초 값을 하나 정해서 해당 값으로 부터 다른 값들을 분기해나가며 확장하는 방법이다. <br>
이를 간단히 정의하면 다음과 같다.

```
# 조건
1) 순열의 길이가 전체 원소의 개수가 될 것
2) 이전에 포함하지 않은 남은 값을 작은 순서대로 포함할 것
2-1) 포함하지 않은 경우, 다음 순서로 미룬다.
```

```js
// javascript

var len = 3;
var permutation = [];
var chosen = new Array(len).fill(false);

function search() {
  if (permutation.length === len) {
    console.log(permutation);
  } else {
    for (let i = 0; i < len; i++) {
      if (!chosen[i]) {
        chosen[i] = true;
        permutation.push(i);
        search();
        chosen[i] = false;
        permutation.pop();
      }
    }
  }
}

```
<br>
<br>

### 2.2.3 퇴각 검색
퇴각 검색이란, 비어있는 해로 탐색을 시작하고, 단계마다 해를 확장해 나가는 방식의 알고리즘이다. (간단히 말하면 현재 항으로 부터 파생 가능한 모든 항을 탐색할 수 없을 때까지 탐색한다.)

책에서는 해당 알고리즘의 예제로 체스판을 들고 있다.<br> 

두 개의 퀸이 4*4 체스판에서 서로 공격할 수 없는 배치를 구하기 위해선, 1개의 퀸을 배치하고, 모든 칸에 대해서 나머지 퀸의 위치를 탐색, 다시 다음 칸으로 재배치 후 같은 과정을 반복한다.

```js
// 망할 백트래킹...

const col = new Array(16).fill(0);
const diag1 = new Array(16).fill(0);
const diag2 = new Array(16).fill(0);
const n = 4;
let count = 0;

function search(y = 0) {
  if (y === n) {
    count++;
    return;
  }

  for (let x = 0; x < n; x++) {
    if (!(col[x] || diag1[x+y] || diag2[x-y+n-1])) {
      col[x] = diag1[x+y] = diag2[x-y+n-1] = 1;
      search(y+1);
      col[x] = diag1[x+y] = diag2[x-y+n-1] = 0;
    }
  }
}

search();
console.log(count);
```

### 2.3 비트 연산

알고리즘의 세계에서 비트 연산은 생각보다 중요하다.
일반적인 실무에서 비트 연산이 꼭 필요한 케이스는 많지 않으나, 알고리즘에서 보통 같이 언급되는 이유는 비트 연산을 이용해 굉장히 효율적으로 코드를 처리할 수 있기 때문이다.

### 2.3.1 기본적인 비트 연산
기본적인 비트 연산은 다음과 같다. 
1. And 연산 (*)
2. Or 연산 (+)
3. Xor 연산 (^) - 둘 중에 하나에만 비트 1이 있는 경우에 1을 반환한다.
4. Not 연산 (~)

#### 비트 쉬프트
```c
x << k
# 정수의 오른쪽에 비트 0을 n개 붙인다.

x >> k 
# 정수의 왼쪽에 비트 0을 n개 붙인다.
```

#### 비트 마스크
```c
1 << k
```

비트 마스크란 해당 위치의 비트를 제외한 나머지를 0 처리한 정수이다.
해당 연산을 이용하여, 반복문을 통해 해당 정수의 비트를 확인하는데 사용할 수 있다.

```c
x & (1 << k)
```

### 2.3.2 집합 표현하기

n 비트 정수를 통해 n항의 부분집합 표현 가능
```c
int x = 0; # 00000000000000000000000000000000
x |\ (1 << 1);
x |\ (1 << 3);
x |\ (1 << 4);
x |\ (1 << 8);

# 00000000000000000000000100011010
```

## 3. 효율성

알고리즘의 효율성을 따질 때, 보통 시간 복잡도를 언급한다.
시간 복잡도(Time complexity)란, 입력에 대해 알고리즘이 얼마만큼의 시간을 사용할지를 근사적으로 알려준다. 

빅오 표기법 `O(...)` 로 표기하며, 반복횟수를 n으로 표현하여 1, n, n^2, logn 등으로 실제 연산을 하지 않고도, 알고리즘의 성능을 측정할 수 있다.

별개의 이야기지만, 점화식으로 식을 풀어낼 수 있으면, 관계를 통해 보다 나은 효율의 알고리즘을 작성할 수 있다. (고등 수학의 수열과 점화식을 생각해보자.)